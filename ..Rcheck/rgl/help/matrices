matrices                 package:rgl                 R Documentation

_W_o_r_k _w_i_t_h _h_o_m_o_g_e_n_e_o_u_s _c_o_o_r_d_i_n_a_t_e_s

_D_e_s_c_r_i_p_t_i_o_n:

     These functions construct 4x4 matrices for transformations in the
     homogeneous coordinate system used by OpenGL, and translate
     vectors between homogeneous and Euclidean coordinates.

_U_s_a_g_e:

     identityMatrix()
     scaleMatrix(x, y, z)
     translationMatrix(x, y, z)
     rotationMatrix(angle, x, y, z, matrix)
     asHomogeneous(x)
     asEuclidean(x)

     scale3d(obj, x, y, z, ...)
     translate3d(obj, x, y, z, ...)
     rotate3d(obj, angle, x, y, z, matrix, ...)

     transform3d(obj, matrix, ...)

_A_r_g_u_m_e_n_t_s:

x, y, z, angle, matrix: See details

     obj: An object to be transformed

     ...: Additional parameters to be passed to methods

_D_e_t_a_i_l_s:

     OpenGL uses homogeneous coordinates to handle perspective and
     affine transformations.  The homogeneous point '(x, y, z, w)'
     corresponds to the Euclidean point '(x/w, y/w, z/w)'.  The
     matrices produced by the functions 'scaleMatrix',
     'translationMatrix', and 'rotationMatrix' are to be
     left-multiplied by a row vector  of homogeneous coordinates;
     alternatively, the transpose of the result can be right-multiplied
     by a column vector.  The generic functions 'scale3d',
     'translate3d' and 'rotate3d' apply these transformations to the
     'obj' argument.  The 'transform3d' function is a synonym  for
     'rotate3d(obj, matrix=matrix)'.

     By default, it is assumed that 'obj' is a row vector (or a matrix
     of row vectors) which will be multiplied on the right by the
     corresponding matrix, but users may write methods for these
     generics which operate differently.  Methods are supplied for
     'qmesh3d' objects.

     To compose transformations, use matrix multiplication.  The effect
     is to apply the matrix on the left first, followed by the one on
     the right.

     'identityMatrix' returns an identity matrix.

     'scaleMatrix' scales each coordinate by the given factor.  In
     Euclidean coordinates, '(u, v, w)' is transformed to '(x*u, y*v,
     z*w)'.

     'translationMatrix' translates each coordinate by the given
     translation, i.e. '(u,v,w)' is transformed to '(u+x,v+y,w+z)'.

     'rotationMatrix' can be called in three ways.  With  arguments
     'angle, x, y, z' it represents a rotation  of 'angle' radians
     about the axis  'x, y, z'.  If a 3x3 rotation matrix can be given;
     it will be converted into the corresponding matrix in 4x4
     homogeneous coordinates.  Finally, if a 4x4 matrix is given, it
     will be returned unchanged. (The latter behaviour is used to allow
     'transform3d' to act like a  generic function, even though it is
     not.)

     Use 'asHomogeneous(x)' to convert the Euclidean vector 'x' to
     homogeneous coordinates, and 'asEuclidean(x)' for the reverse
     transformation.

_V_a_l_u_e:

     'identityMatrix', 'scaleMatrix', 'translationMatrix', and
     'rotationMatrix' produce a 4x4 matrix representing the requested
     transformation in homogeneous coordinates.  

     'scale3d', 'translate3d' and 'rotate3d' transform the object and
     produce a new object of the same class.

_A_u_t_h_o_r(_s):

     Duncan Murdoch

_S_e_e _A_l_s_o:

     'par3d' for a description of how rgl uses matrices in rendering.

_E_x_a_m_p_l_e_s:

     # A 90 degree rotation about the x axis:

     rotationMatrix(pi/2, 1, 0, 0)

     # Find what happens when you rotate (2,0,0) by 45 degrees about the y axis:

     x <- asHomogeneous(c(2,0,0))
     y <- x 
     asEuclidean(y)

     # or more simply...

     rotate3d(c(2,0,0), pi/4, 0, 1, 0)

