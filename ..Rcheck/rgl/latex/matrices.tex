\HeaderA{matrices}{Work with homogeneous coordinates}{matrices}
\aliasA{asEuclidean}{matrices}{asEuclidean}
\aliasA{asHomogeneous}{matrices}{asHomogeneous}
\aliasA{identityMatrix}{matrices}{identityMatrix}
\aliasA{rotate3d}{matrices}{rotate3d}
\aliasA{rotationMatrix}{matrices}{rotationMatrix}
\aliasA{scale3d}{matrices}{scale3d}
\aliasA{scaleMatrix}{matrices}{scaleMatrix}
\aliasA{transform3d}{matrices}{transform3d}
\aliasA{translate3d}{matrices}{translate3d}
\aliasA{translationMatrix}{matrices}{translationMatrix}
\keyword{dynamic}{matrices}
\begin{Description}\relax
These functions construct 4x4 matrices for transformations
in the homogeneous coordinate system used by OpenGL, and translate
vectors between homogeneous and Euclidean coordinates.
\end{Description}
\begin{Usage}
\begin{verbatim}
identityMatrix()
scaleMatrix(x, y, z)
translationMatrix(x, y, z)
rotationMatrix(angle, x, y, z, matrix)
asHomogeneous(x)
asEuclidean(x)

scale3d(obj, x, y, z, ...)
translate3d(obj, x, y, z, ...)
rotate3d(obj, angle, x, y, z, matrix, ...)

transform3d(obj, matrix, ...)

\end{verbatim}
\end{Usage}
\begin{Arguments}
\begin{ldescription}
\item[\code{x, y, z, angle, matrix}] See details
\item[\code{obj}] An object to be transformed
\item[\code{...}] Additional parameters to be passed to methods
\end{ldescription}
\end{Arguments}
\begin{Details}\relax
OpenGL uses homogeneous coordinates to handle perspective and affine
transformations.  The homogeneous point \code{(x, y, z, w)} corresponds
to the Euclidean point \code{(x/w, y/w, z/w)}.  The matrices produced by
the functions \code{scaleMatrix}, \code{translationMatrix}, and \code{rotationMatrix}
are to be left-multiplied by a row vector 
of homogeneous coordinates; alternatively, the transpose of the result
can be right-multiplied by a column vector.  The generic functions
\code{scale3d}, \code{translate3d} and \code{rotate3d} apply these transformations
to the \code{obj} argument.  The \code{transform3d} function is a synonym 
for \code{rotate3d(obj, matrix=matrix)}.

By default, it is assumed that \code{obj} is a row vector
(or a matrix of row vectors) which will be multiplied on the right by
the corresponding matrix, but users may write methods for these generics
which operate differently.  Methods are supplied for \code{\LinkA{qmesh3d}{qmesh3d}}
objects.

To compose transformations, use matrix multiplication.  The effect is
to apply the matrix on the left first, followed by the one on the right.

\code{identityMatrix} returns an identity matrix.

\code{scaleMatrix} scales each coordinate by the given factor.  In Euclidean
coordinates, \code{(u, v, w)} is transformed to \code{(x*u, y*v, z*w)}.

\code{translationMatrix} translates each coordinate by the given translation, i.e.
\code{(u,v,w)} is transformed to \code{(u+x,v+y,w+z)}.

\code{rotationMatrix} can be called in three ways.  With 
arguments \code{angle, x, y, z} it represents a rotation 
of \code{angle} radians about the axis 
\code{x, y, z}.  If a 3x3 rotation matrix can be given;
it will be converted into the corresponding matrix in 4x4 homogeneous
coordinates.  Finally, if a 4x4 matrix is given, it will be returned unchanged.
(The latter behaviour is used to allow \code{transform3d} to act like a 
generic function, even though it is not.)

Use \code{asHomogeneous(x)} to convert the Euclidean vector \code{x} to
homogeneous coordinates, and \code{asEuclidean(x)} for the reverse transformation.
\end{Details}
\begin{Value}
\code{identityMatrix},
\code{scaleMatrix}, \code{translationMatrix}, and \code{rotationMatrix} produce
a 4x4 matrix representing the requested transformation
in homogeneous coordinates.  

\code{scale3d}, \code{translate3d} and \code{rotate3d} transform the object
and produce a new object of the same class.
\end{Value}
\begin{Author}\relax
Duncan Murdoch
\end{Author}
\begin{SeeAlso}\relax
\code{\LinkA{par3d}{par3d}} for a description of how rgl uses matrices in
rendering.
\end{SeeAlso}
\begin{Examples}
\begin{ExampleCode}
# A 90 degree rotation about the x axis:

rotationMatrix(pi/2, 1, 0, 0)

# Find what happens when you rotate (2,0,0) by 45 degrees about the y axis:

x <- asHomogeneous(c(2,0,0))
y <- x 
asEuclidean(y)

# or more simply...

rotate3d(c(2,0,0), pi/4, 0, 1, 0)

\end{ExampleCode}
\end{Examples}

