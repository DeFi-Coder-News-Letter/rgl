
R version 2.5.0 Under development (unstable) (2006-10-06 r39594)
Copyright (C) 2006 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(rgl)
> 
> for(demo in demo(package="rgl")$results[,"Item"]) 
+   demo(demo, package="rgl", character.only=TRUE)


	demo(abundance)
	---- ~~~~~~~~~

> rgl.demo.abundance <- function() {
    clear3d("all")
    bg3d(col = "#cccccc")
    light3d()
    terrain <- dget(system.file("demodata/region.dat", package = "rgl"))
    pop <- dget(system.file("demodata/population.dat", package = "rgl"))
    zlim < .... [TRUNCATED] 

> rgl.open()

> rgl.demo.abundance()


	demo(bivar)
	---- ~~~~~

> rgl.demo.bivar <- function() {
    require(MASS)
    n <- 50
    ngrid <- 40
    set.seed(31415)
    x <- rnorm(n)
    y <- rnorm(n)
    denobj <- kde2d(x, y, n = ngrid)
    den.z <- denobj$z
    xgrid <- denobj$x
    ygrid <- denobj$y
    bi.z <- dn .... [TRUNCATED] 

> rgl.open()

> rgl.demo.bivar()
Loading required package: MASS


	demo(envmap)
	---- ~~~~~~

> rgl.demo.envmap <- function() {
    clear3d("all")
    light3d()
    bg3d(sphere = T, color = "white", back = "filled", texture = system.file("textures/refmap.png", 
        package = "rgl"))
    data(volcano)
    surface3d(10 * 1:nrow(volcano), 10 * .... [TRUNCATED] 

> rgl.open()

> rgl.demo.envmap()


	demo(hist3d)
	---- ~~~~~~

> binplot.3d <- function(x, y, z, alpha = 1, topcol = "#ff0000", 
    sidecol = "#aaaaaa") {
    save <- par3d(skipRedraw = TRUE)
    on.exit(par3d(save))
    x1 <- c(rep(c(x[1], x[2], x[2], x[1]), 3), rep(x[1], 4), 
        rep(x[2], 4))
    z1 <- c(r .... [TRUNCATED] 

> hist3d <- function(x, y = NULL, nclass = "auto", alpha = 1, 
    col = "#ff0000", scale = 10) {
    save <- par3d(skipRedraw = TRUE)
    on.exit(par3d(save))
    xy <- xy.coords(x, y)
    x <- xy$x
    y <- xy$y
    n <- length(x)
    if (nclass == " ..." ... [TRUNCATED] 

> rgl.open()

> rgl.bg(color = "gray")

> rgl.light()

> binplot.3d(c(-0.5, 0.5), c(4.5, 5.5), 2, alpha = 0.6)

> rgl.viewpoint(theta = 40, phi = 40)

> rgl.bg(col = "#cccccc")

> rgl.open()

> alpha <- 0.7

> topcol <- "#ff0000"

> sidecol <- "#aaaaaa"

> y <- x <- c(-1, 1)

> z <- 4

> of <- 0.3

> x12 <- c(x[1], x[2], x[2], x[1])

> x11 <- rep(x[1], 4)

> x22 <- rep(x[2], 4)

> z00 <- rep(0, 4)

> z0z <- c(0, 0, z, z)

> zzz <- rep(z, 4)

> y11 <- rep(y[1], 4)

> y1122 <- c(y[1], y[1], y[2], y[2])

> y12 <- c(y[1], y[2], y[2], y[1])

> y22 <- rep(y[2], 4)

> rgl.quads(c(x12, x12, x11 - of, x12, x22 + of, x12), 
    c(z00 - of, rep(z0z, 4), zzz + of), c(y1122, y11 - of, y12, 
        y22 + of, y12, y1122), col = rep(c(rep(sidecol, 5), topcol), 
        each = 4), alpha = c(rep(alpha, 5), 1))

> yl1 <- c(y[1], y[2], y[1], y[2])

> yl2 <- c(y[1] - of, y[1] - of)

> xl <- c(rep(x[1], 8), rep(x[1] - of, 8), rep(c(x[1], 
    x[2]), 8), rep(x[2], 8), rep(x[2] + of, 8))

> zl <- c(0, z, 0, z, z + of, z + of, -of, -of, 0, 0, 
    z, z, 0, z, 0, z, rep(0, 4), rep(z, 4), rep(-of, 4), rep(z + 
        of, 4), z + of, z + of, -of, -of, rep(c(0, z), 4), 0, 
    0, z, z)

> yl <- c(yl2, y[2] + of, y[2] + of, rep(c(y[1], y[2]), 
    4), y[1], y[1], y[2], y[2], yl2, rep(y[2] + of, 4), yl2, 
    y[2], y[2], rep(y[1], 4), y[2], y[2], yl1, yl2, y[2] + of, 
    y[2] + of, y[1], y[1], y[2], y[2], yl1)

> rgl.lines(xl, zl, yl, col = "#000000")

> rgl.open()

> rgl.bg(col = "#cccccc")

> set.seed(1000)

> hist3d(rnorm(2500), rnorm(2500), alpha = 0.4, nclass = 7, 
    scale = 30)


	demo(lollipop3d)
	---- ~~~~~~~~~~

> cone3d <- function(base, tip, rad, n = 30, ...) {
    degvec <- seq(0, 2 * pi, length = n)
    ax <- tip - base
    if (ax[1] != 0) {
        p1 <- c(-ax[2]/ax[1], 1, 0)
        p1 <- p1/sqrt(sum(p1^2))
        if (p1[1] != 0) {
            p2 <- c(- .... [TRUNCATED] 

> lollipop3d <- function(data.x, data.y, data.z, surf.fun, 
    surf.n = 50, xlim = range(data.x), ylim = range(data.y), 
    zlim = range(data.z), asp = c(y = 1, z = 1), xlab = deparse(substitute(x)), 
    ylab = deparse(substitute(y)), zlab = deparse .... [TRUNCATED] 

> x <- 1:5

> y <- x * 10

> z <- (x + y)/20

> open3d()
[1] 7

> spheres3d(x, y, z)

> axes3d()

> set.seed(1001)

> x <- runif(30)

> y <- runif(30, max = 2)

> dfun <- function(x, y) {
    2 * x + 3 * y + 2 * x * y + 3 * y^2
}

> z <- dfun(x, y) + rnorm(30, sd = 0.5)

> lollipop3d(x, y, z)

> open3d()
[1] 8

> lollipop3d(x, y, z, dfun, col.pt = "red", col.stem = c("red", 
    "blue"))

> open3d()
[1] 9

> linmodel <- lm(z ~ x + y)

> dfun <- function(x, y) {
    predict(linmodel, newdata = data.frame(x = x, y = y))
}

> lollipop3d(x, y, z, dfun, col.pt = "red", col.stem = c("red", 
    "blue"))


	demo(lsystem)
	---- ~~~~~~~

> deg2rad <- function(degree) {
    return(degree * pi/180)
}

> rotZ.m3x3 <- function(degree) {
    kc <- cos(deg2rad(degree))
    ks <- sin(deg2rad(degree))
    return(matrix(c(kc, -ks, 0, ks, kc, 0, 0, 0, 1), ncol = 3, 
        byrow = T))
}

> rotX.m3x3 <- function(degree) {
    kc <- cos(deg2rad(degree))
    ks <- sin(deg2rad(degree))
    return(matrix(c(1, 0, 0, 0, kc, -ks, 0, ks, kc), ncol = 3, 
        byrow = T))
}

> rotY.m3x3 <- function(degree) {
    kc <- cos(deg2rad(degree))
    ks <- sin(deg2rad(degree))
    return(matrix(c(kc, 0, ks, 0, 1, 0, -ks, 0, kc), ncol = 3, 
        byrow = T))
}

> rotZ <- function(v, degree) {
    return(rotZ.m3x3(degree) %*% v)
}

> rotX <- function(v, degree) {
    return(rotX.m3x3(degree) %*% v)
}

> rotY <- function(v, degree) {
    return(rotY.m3x3(degree) %*% v)
}

> turtle.init <- function(pos = c(0, 0, 0), head = 0, 
    pitch = 90, roll = 0, level = 0) {
    rgl.clear("all")
    rgl.bg(color = "black")
    rgl.light()
    return(list(pos = pos, head = head, pitch = pitch, roll = roll, 
        level = level))
 .... [TRUNCATED] 

> turtle.move <- function(turtle, steps, color) {
    rm <- rotX.m3x3(turtle$pitch) %*% rotY.m3x3(turtle$head) %*% 
        rotZ.m3x3(turtle$roll)
    from <- as.vector(turtle$pos)
    dir <- rm %*% c(0, 0, -1)
    to <- from + dir * steps
    x <- c(f .... [TRUNCATED] 

> turtle.pitch <- function(turtle, degree) {
    turtle$pitch <- turtle$pitch + degree
    return(turtle)
}

> turtle.head <- function(turtle, degree) {
    turtle$head <- turtle$head + degree
    return(turtle)
}

> turtle.roll <- function(turtle, degree) {
    turtle$roll <- turtle$roll + degree
    return(turtle)
}

> lsystem.code <- function(x) substitute(x)

> lsystem.gen <- function(x, grammar, levels = 0) {
    code <- eval(substitute(substitute(REPLACE, grammar), list(REPLACE = x)))
    if (levels) 
        return(lsystem.gen(code, grammar, levels - 1))
    else return(code)
}

> lsystem.plot <- function(expr, level) {
    turtle <- turtle.init(level = level)
    lsystem.eval(expr, turtle)
}

> lsystem.eval <- function(expr, turtle) {
    if (length(expr) == 3) {
        turtle <- lsystem.eval(expr[[2]], turtle)
        turtle <- lsystem.eval(expr[[3]], turtle)
        turtle <- lsystem.eval(expr[[1]], turtle)
    }
    else if (length(expr .... [TRUNCATED] 

> simple <- function(level = 0) {
    grammar <- list(stem = lsystem.code(stem - (up - stem - leaf) - 
        stem - (down - stem - leaf) - stem - leaf))
    plant <- lsystem.gen(lsystem.code(stem), grammar, level)
    lsystem.plot(plant, level)
}

> rgl.demo.lsystem <- function(level = 0) {
    gen <- list(stem = lsystem.code(stem - left - stem - branch(turnleft - 
        down - short - turnleft - down - stem - leaf) - right - 
        right - stem - -branch(turnright - up - short - turnright - .... [TRUNCATED] 

> rgl.open()

> rgl.demo.lsystem(level = 1)
$pos
              [,1]
[1,] -2.092747e+00
[2,]  7.992083e+01
[3,] -4.893578e-15

$head
[1] 5

$pitch
[1] 90

$roll
[1] 0

$level
[1] 1



	demo(regression)
	---- ~~~~~~~~~~

> rgl.demo.regression <- function(n = 100, xa = 3, za = 8, 
    xb = 0.02, zb = 0.01, xlim = c(0, 100), zlim = c(0, 100)) {
    rgl.clear("all")
    rgl.bg(sphere = TRUE, color = c("black", "green"), lit = FALSE, 
        size = 2, alpha = 0.2, back =  .... [TRUNCATED] 

> rgl.open()

> rgl.demo.regression()


	demo(rgl)
	---- ~~~

> demo(hist3d)


	demo(hist3d)
	---- ~~~~~~

> binplot.3d <- function(x, y, z, alpha = 1, topcol = "#ff0000", 
    sidecol = "#aaaaaa") {
    save <- par3d(skipRedraw = TRUE)
    on.exit(par3d(save))
    x1 <- c(rep(c(x[1], x[2], x[2], x[1]), 3), rep(x[1], 4), 
        rep(x[2], 4))
    z1 <- c(r .... [TRUNCATED] 

> hist3d <- function(x, y = NULL, nclass = "auto", alpha = 1, 
    col = "#ff0000", scale = 10) {
    save <- par3d(skipRedraw = TRUE)
    on.exit(par3d(save))
    xy <- xy.coords(x, y)
    x <- xy$x
    y <- xy$y
    n <- length(x)
    if (nclass == " ..." ... [TRUNCATED] 

> rgl.open()

> rgl.bg(color = "gray")

> rgl.light()

> binplot.3d(c(-0.5, 0.5), c(4.5, 5.5), 2, alpha = 0.6)

> rgl.viewpoint(theta = 40, phi = 40)

> rgl.bg(col = "#cccccc")

> rgl.open()

> alpha <- 0.7

> topcol <- "#ff0000"

> sidecol <- "#aaaaaa"

> y <- x <- c(-1, 1)

> z <- 4

> of <- 0.3

> x12 <- c(x[1], x[2], x[2], x[1])

> x11 <- rep(x[1], 4)

> x22 <- rep(x[2], 4)

> z00 <- rep(0, 4)

> z0z <- c(0, 0, z, z)

> zzz <- rep(z, 4)

> y11 <- rep(y[1], 4)

> y1122 <- c(y[1], y[1], y[2], y[2])

> y12 <- c(y[1], y[2], y[2], y[1])

> y22 <- rep(y[2], 4)

> rgl.quads(c(x12, x12, x11 - of, x12, x22 + of, x12), 
    c(z00 - of, rep(z0z, 4), zzz + of), c(y1122, y11 - of, y12, 
        y22 + of, y12, y1122), col = rep(c(rep(sidecol, 5), topcol), 
        each = 4), alpha = c(rep(alpha, 5), 1))

> yl1 <- c(y[1], y[2], y[1], y[2])

> yl2 <- c(y[1] - of, y[1] - of)

> xl <- c(rep(x[1], 8), rep(x[1] - of, 8), rep(c(x[1], 
    x[2]), 8), rep(x[2], 8), rep(x[2] + of, 8))

> zl <- c(0, z, 0, z, z + of, z + of, -of, -of, 0, 0, 
    z, z, 0, z, 0, z, rep(0, 4), rep(z, 4), rep(-of, 4), rep(z + 
        of, 4), z + of, z + of, -of, -of, rep(c(0, z), 4), 0, 
    0, z, z)

> yl <- c(yl2, y[2] + of, y[2] + of, rep(c(y[1], y[2]), 
    4), y[1], y[1], y[2], y[2], yl2, rep(y[2] + of, 4), yl2, 
    y[2], y[2], rep(y[1], 4), y[2], y[2], yl1, yl2, y[2] + of, 
    y[2] + of, y[1], y[1], y[2], y[2], yl1)

> rgl.lines(xl, zl, yl, col = "#000000")

> rgl.open()

> rgl.bg(col = "#cccccc")

> set.seed(1000)

> hist3d(rnorm(2500), rnorm(2500), alpha = 0.4, nclass = 7, 
    scale = 30)

> demo(abundance)


	demo(abundance)
	---- ~~~~~~~~~

> rgl.demo.abundance <- function() {
    clear3d("all")
    bg3d(col = "#cccccc")
    light3d()
    terrain <- dget(system.file("demodata/region.dat", package = "rgl"))
    pop <- dget(system.file("demodata/population.dat", package = "rgl"))
    zlim < .... [TRUNCATED] 

> rgl.open()

> rgl.demo.abundance()

> demo(regression)


	demo(regression)
	---- ~~~~~~~~~~

> rgl.demo.regression <- function(n = 100, xa = 3, za = 8, 
    xb = 0.02, zb = 0.01, xlim = c(0, 100), zlim = c(0, 100)) {
    rgl.clear("all")
    rgl.bg(sphere = TRUE, color = c("black", "green"), lit = FALSE, 
        size = 2, alpha = 0.2, back =  .... [TRUNCATED] 

> rgl.open()

> rgl.demo.regression()

> demo(lsystem)


	demo(lsystem)
	---- ~~~~~~~

> deg2rad <- function(degree) {
    return(degree * pi/180)
}

> rotZ.m3x3 <- function(degree) {
    kc <- cos(deg2rad(degree))
    ks <- sin(deg2rad(degree))
    return(matrix(c(kc, -ks, 0, ks, kc, 0, 0, 0, 1), ncol = 3, 
        byrow = T))
}

> rotX.m3x3 <- function(degree) {
    kc <- cos(deg2rad(degree))
    ks <- sin(deg2rad(degree))
    return(matrix(c(1, 0, 0, 0, kc, -ks, 0, ks, kc), ncol = 3, 
        byrow = T))
}

> rotY.m3x3 <- function(degree) {
    kc <- cos(deg2rad(degree))
    ks <- sin(deg2rad(degree))
    return(matrix(c(kc, 0, ks, 0, 1, 0, -ks, 0, kc), ncol = 3, 
        byrow = T))
}

> rotZ <- function(v, degree) {
    return(rotZ.m3x3(degree) %*% v)
}

> rotX <- function(v, degree) {
    return(rotX.m3x3(degree) %*% v)
}

> rotY <- function(v, degree) {
    return(rotY.m3x3(degree) %*% v)
}

> turtle.init <- function(pos = c(0, 0, 0), head = 0, 
    pitch = 90, roll = 0, level = 0) {
    rgl.clear("all")
    rgl.bg(color = "black")
    rgl.light()
    return(list(pos = pos, head = head, pitch = pitch, roll = roll, 
        level = level))
 .... [TRUNCATED] 

> turtle.move <- function(turtle, steps, color) {
    rm <- rotX.m3x3(turtle$pitch) %*% rotY.m3x3(turtle$head) %*% 
        rotZ.m3x3(turtle$roll)
    from <- as.vector(turtle$pos)
    dir <- rm %*% c(0, 0, -1)
    to <- from + dir * steps
    x <- c(f .... [TRUNCATED] 

> turtle.pitch <- function(turtle, degree) {
    turtle$pitch <- turtle$pitch + degree
    return(turtle)
}

> turtle.head <- function(turtle, degree) {
    turtle$head <- turtle$head + degree
    return(turtle)
}

> turtle.roll <- function(turtle, degree) {
    turtle$roll <- turtle$roll + degree
    return(turtle)
}

> lsystem.code <- function(x) substitute(x)

> lsystem.gen <- function(x, grammar, levels = 0) {
    code <- eval(substitute(substitute(REPLACE, grammar), list(REPLACE = x)))
    if (levels) 
        return(lsystem.gen(code, grammar, levels - 1))
    else return(code)
}

> lsystem.plot <- function(expr, level) {
    turtle <- turtle.init(level = level)
    lsystem.eval(expr, turtle)
}

> lsystem.eval <- function(expr, turtle) {
    if (length(expr) == 3) {
        turtle <- lsystem.eval(expr[[2]], turtle)
        turtle <- lsystem.eval(expr[[3]], turtle)
        turtle <- lsystem.eval(expr[[1]], turtle)
    }
    else if (length(expr .... [TRUNCATED] 

> simple <- function(level = 0) {
    grammar <- list(stem = lsystem.code(stem - (up - stem - leaf) - 
        stem - (down - stem - leaf) - stem - leaf))
    plant <- lsystem.gen(lsystem.code(stem), grammar, level)
    lsystem.plot(plant, level)
}

> rgl.demo.lsystem <- function(level = 0) {
    gen <- list(stem = lsystem.code(stem - left - stem - branch(turnleft - 
        down - short - turnleft - down - stem - leaf) - right - 
        right - stem - -branch(turnright - up - short - turnright - .... [TRUNCATED] 

> rgl.open()

> rgl.demo.lsystem(level = 1)
$pos
              [,1]
[1,] -2.092747e+00
[2,]  7.992083e+01
[3,] -4.893578e-15

$head
[1] 5

$pitch
[1] 90

$roll
[1] 0

$level
[1] 1


> demo(subdivision)


	demo(subdivision)
	---- ~~~~~~~~~~~

> rgl.demo.subdivision <- function() {
    rgl.clear("all")
    bg3d(color = "gray")
    light3d()
    obj <- oh3d()
    part <- function(level, tx, ...) {
        shade3d(translate3d(obj, tx, 0, 0), color = "gray30", 
            front = "lines", alph .... [TRUNCATED] 

> rgl.open()

> rgl.demo.subdivision()

> demo(bivar)


	demo(bivar)
	---- ~~~~~

> rgl.demo.bivar <- function() {
    require(MASS)
    n <- 50
    ngrid <- 40
    set.seed(31415)
    x <- rnorm(n)
    y <- rnorm(n)
    denobj <- kde2d(x, y, n = ngrid)
    den.z <- denobj$z
    xgrid <- denobj$x
    ygrid <- denobj$y
    bi.z <- dn .... [TRUNCATED] 

> rgl.open()

> rgl.demo.bivar()


	demo(shapes3d)
	---- ~~~~~~~~

> cone3d <- function(base = c(0, 0, 0), tip = c(0, 0, 
    1), rad = 1, n = 30, draw.base = TRUE, qmesh = FALSE, trans = par3d("userMatrix"), 
    ...) {
    ax <- tip - base
    if (missing(trans) && !rgl.cur()) 
        trans <- diag(4)
    if (ax[1] .... [TRUNCATED] 

> ellipsoid3d <- function(rx = 1, ry = 1, rz = 1, n = 30, 
    ctr = c(0, 0, 0), qmesh = FALSE, trans = par3d("userMatrix"), 
    ...) {
    if (missing(trans) && !rgl.cur()) 
        trans <- diag(4)
    degvec <- seq(0, 2 * pi, length = n)
    ecoord .... [TRUNCATED] 

> open3d()
[1] 20

> ellipsoid3d(ctr = c(2, 2, 2), rx = 3, ry = 2, col = "red", 
    alpha = 0.4)

> cone3d(base = c(-2, -2, -2), rad = 0.5, tip = c(-3, 
    0, -4), col = "blue", front = "lines", back = "lines")

> shade3d(translate3d(cube3d(), 3, -2, 3, col = "purple"))

> open3d()
[1] 21

> q1 <- cone3d(qmesh = TRUE, trans = diag(4))

> shade3d(q1)

> wire3d(translate3d(q1, 3, 0, 0), col = "green")

> wire3d(translate3d(scale3d(q1, 1, 1, 2), 6, 0, 0), 
    col = "green")

> dot3d(translate3d(q1, 0, 3, 0), col = "green")

> dot3d(translate3d(scale3d(q1, 2, 1, 1), 0, 6, 0), 
    col = "green")

> shade3d(translate3d(q1, 0, 0, 3), col = "red")

> shade3d(translate3d(rotate3d(scale3d(q1, 1, 1, 2), 
    pi/4, 0, 1, 0), 0, 0, 6), col = "red")

> axes3d()

> open3d()
[1] 22

> s1 <- ellipsoid3d(qmesh = TRUE, trans = diag(4))

> shade3d(s1)

> wire3d(translate3d(s1, 3, 0, 0), col = "green")

> wire3d(translate3d(scale3d(s1, 1, 1, 2), 6, 0, 0), 
    col = "green")

> dot3d(translate3d(s1, 0, 3, 0), col = "green")

> dot3d(translate3d(scale3d(s1, 2, 1, 1), 0, 6, 0), 
    col = "green")

> shade3d(translate3d(s1, 0, 0, 3), col = "red")

> shade3d(translate3d(rotate3d(scale3d(s1, 1, 1, 2), 
    pi/4, 0, 1, 0), 0, 0, 6), col = "red")

> axes3d()


	demo(subdivision)
	---- ~~~~~~~~~~~

> rgl.demo.subdivision <- function() {
    rgl.clear("all")
    bg3d(color = "gray")
    light3d()
    obj <- oh3d()
    part <- function(level, tx, ...) {
        shade3d(translate3d(obj, tx, 0, 0), color = "gray30", 
            front = "lines", alph .... [TRUNCATED] 

> rgl.open()

> rgl.demo.subdivision()
> 
